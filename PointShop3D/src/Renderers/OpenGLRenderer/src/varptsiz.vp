!!VP1.0

#
# First, we only try to project wrong colored points with a size that
# is proportional to the normal length
#


# Program Parameters:
#
#  MatrixP3   varPtSizExtrTransf;        // vertex program parameters 8..11
#  MatrixP3   varPtSizExtrTransfInv;     // May I avoid it?
#  float      varPtSizF2;                // vertex program parameter 68.xyzw
#
#  VectorR3  varPtSizExtrTransfR[3];     // vertex program parameters 8..11
#  VectorR3  varPtSizExtrTransfT;        // vertex program parameter 64
#  PointR3   varPtSizExtrTransfPOV;      // vertex program parameter 65
#

# Vertex Attributes:
#
#  Position
#  Normal (length does matter)
#  Color (will not be lit)
#

# My constants
#
#              x     y      z      w
#
#   c[50]:   -1.0   0.0     1.0    2.0
#   c[51]:    0.5   0.333   0.25   0.75
#   c[52]:    3.0   4.0     5.0   6.0
#   c[53]:    7.0   8.0     9.0   10.0
#   c[54]:    15.   21.    27.   33.
#   c[55]:    66.   100.   150.   200.
#   c[56]:   .15     .1     .05  .025
#
#   c[57]:    100   xx  xx  xx
#

# Project position to clip-space (-> R0)
#
DP4  R0.x, c[0], v[OPOS];
DP4  R0.y, c[1], v[OPOS];
DP4  R0.z, c[2], v[OPOS];
DP4  R0.w, c[3], v[OPOS];

MOV  R5, R0;
MOV  o[HPOS], R0;

# pViewLocal to R1:
#  const PointR3  pViewLocal(varPtSizExtrTransfR[0] * p + varPtSizExtrTransfT.p[0],
#			     varPtSizExtrTransfR[1] * p + varPtSizExtrTransfT.p[1],
#			     varPtSizExtrTransfR[2] * p + varPtSizExtrTransfT.p[2]);

MOV  R3, v[OPOS];		#  (temp: R3 takes v[OPOS], since only one v[] per op allowed)
DP3  R1.x, c[8], R3;		# pViewLocal.x = varPtSizExtrTransfR[0] * p
DP3  R1.y, c[9], R3;		# pViewLocal.y = varPtSizExtrTransfR[1] * p
DP3  R1.z, c[10], R3;		# pViewLocal.z = varPtSizExtrTransfR[2] * p
ADD  R1, c[64], R1;		# add varPtSizExtrTransfT to pViewLocal

# now, 'z' is in R1.z:
#  const float  z = pViewLocal.p[2];
#

# viewD to R1 (pViewLocal isn't needed anymore):
#  const VectorR3  viewD = ((varPtSizF2 / (z*z*z)) * pViewLocal);
#
MUL  R2, R1.z, R1.z;		#  (R2 = z*z)
MUL  R2, R2, R1.z;	        #  (R2 = z*z*z)
RCP  R2, R2.z;			#  (R2 = 1/(z*z*z))
MUL  R2, c[68].x, R2;		#  (R2 = varPtSizF2/(z*z*z))
MUL  R1, R2, R1;		#  (R1 = ((varPtSizF2 / (z*z*z)) * pViewLocal))

# size to R1 (viewD is not needed anymore):
#  const float  size = sqrt(viewD.abs()) * 2*r;
#
#  -- in fact, we compute size = 1/(sqrt(1/sqrt(viewD * viewD) * 1/((2*r)^2)))
#
#     Thus, the OpenGL-App must encode the radius by setting the
#     normal to a length of 1/(2r)!!
#
#
DP3  R1, R1, R1;		#  (R1 = viewD*viewD)
RSQ  R1, R1.x;			#  (R1 = 1/(viewD.abs()))
DP3  R4, v[NRML], v[NRML];	#  (R2 = nrml.sqabs())
MUL  R1, R1.x, R4.x;		#  (R1 = 1/(viewD.abs()) * nrml.sqabs())
RSQ  o[PSIZ], R1.x;		#  (PSIZ = sqrt(viewD.abs()) * 1/nrml.abs())

# Now, by the way, the squared normal is in R4

# Point color
#
##MOV  o[COL0], v[COL0].yzxw;
#MOV  o[COL0], v[COL0];

# Compute lighting for directional light and local viewer
#
#   normalized light direction in c[32]; light direction must
#   be in *object* coordinates
#
ADD R0, c[65], -v[OPOS];	# view-vector in object coords...
DP3 R1, R0, R0;
RSQ R1.x, R1.x;
MUL R0, R1.xxxx, R0;		# ... normalized

#DP3 R1, v[NRML], v[NRML];	# normal...
#RSQ R1.x, R1.x;
RSQ R1.x, R4.x;			#         we already stored the squared normal in R4
MUL R1, R1.xxxx, v[NRML];	# ... normalized

ADD R2, c[32], R0;		# half-way vector to R2...
DP3 R6, R2, R2;
RSQ R6, R6.x;
MUL R2, R6.xxxx, R2;		# ... done
DP3 R0.y, R2, R1;		# dp3 normal / half-way vector (specular term)

DP3 R0.x, c[32], R1;		# dp3 normal / light vector (diffuse term)

#MOV R0.w, c[57].x;		# specular coefficient of 100
#MOV R0.w, c[50].w;		# specular coefficient of 2
MOV R0.w, c[52].x;		# specular coefficient of 3

LIT R0, R0;

# Now in R0: coeffs {amb, diff, spec, 1.0}

MUL  R1, R0.yyyy, v[COL0];		# diffuse term
#MAD  o[COL0], R0.xxxx, c[51].xxxx, R1;	# ambient term
MAD  o[COL0], R0.zzzz, c[56].xxxx, R1;	# specular term
#MOV  o[COL0], R0.zyyw;			# enable this for color encoded lighting vis

END
