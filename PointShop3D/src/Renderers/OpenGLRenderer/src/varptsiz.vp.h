"!!VP1.0\n"
"\n"
"#\n"
"# Title:   varptsiz.vp\n"
"# Created: Tue Sep 24 17:07:19 2002\n"
"# Author:  Tim Weyrich\n"
"#\n"
"# Copyright (c) 2001, 2002, 2003, Computer Graphics Lab, ETH Zurich\n"
"#\n"
"# This file is part of the Pointshop3D system.\n"
"# See http:#www.pointshop3d.com/ for more information.\n"
"#\n"
"# This program is free software; you can redistribute it and/or\n"
"# modify it under the terms of the GNU Lesser General Public\n"
"# License as published by the Free Software Foundation; either\n"
"# version 2.1 of the License, or (at your option) any later\n"
"# version.\n"
"# \n"
"# This program is distributed in the hope that it will be useful,\n"
"# but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"# GNU Lesser General Public License for more details.\n"
"# \n"
"# You should have received a copy of the GNU Lesser General\n"
"# Public License along with this library; if not, write to the\n"
"# Free Software Foundation, Inc., 59 Temple Place, Suite 330,\n"
"# Boston, MA 02111-1307 USA\n"
"# \n"
"# Contact info@pointshop3d.com if any conditions of this\n"
"# licensing are not clear to you.\n"
"#\n"
"\n"
"#\n"
"# First, we only try to project wrong colored points with a size that\n"
"# is proportional to the normal length\n"
"#\n"
"\n"
"\n"
"# Program Parameters:\n"
"#\n"
"#  MatrixP3   varPtSizExtrTransf;        // vertex program parameters 8..11\n"
"#  MatrixP3   varPtSizExtrTransfInv;     // May I avoid it?\n"
"#  float      varPtSizF2;                // vertex program parameter 68.xyzw\n"
"#\n"
"#  VectorR3  varPtSizExtrTransfR[3];     // vertex program parameters 8..11\n"
"#  VectorR3  varPtSizExtrTransfT;        // vertex program parameter 64\n"
"#  PointR3   varPtSizExtrTransfPOV;      // vertex program parameter 65\n"
"#\n"
"\n"
"# Vertex Attributes:\n"
"#\n"
"#  Position\n"
"#  Normal (length does matter)\n"
"#  Color (will not be lit)\n"
"#\n"
"\n"
"# My constants\n"
"#\n"
"#              x     y      z      w\n"
"#\n"
"#   c[50]:   -1.0   0.0     1.0    2.0\n"
"#   c[51]:    0.5   0.333   0.25   0.75\n"
"#   c[52]:    3.0   4.0     5.0   6.0\n"
"#   c[53]:    7.0   8.0     9.0   10.0\n"
"#   c[54]:    15.   21.    27.   33.\n"
"#   c[55]:    66.   100.   150.   200.\n"
"#   c[56]:   .15     .1     .05  .025\n"
"#\n"
"#   c[57]:    100   xx  xx  xx\n"
"#\n"
"\n"
"# Project position to clip-space (-> R0)\n"
"#\n"
"DP4  R0.x, c[0], v[OPOS];\n"
"DP4  R0.y, c[1], v[OPOS];\n"
"DP4  R0.z, c[2], v[OPOS];\n"
"DP4  R0.w, c[3], v[OPOS];\n"
"\n"
"MOV  R5, R0;\n"
"MOV  o[HPOS], R0;\n"
"\n"
"# pViewLocal to R1:\n"
"#  const PointR3  pViewLocal(varPtSizExtrTransfR[0] * p + varPtSizExtrTransfT.p[0],\n"
"#			     varPtSizExtrTransfR[1] * p + varPtSizExtrTransfT.p[1],\n"
"#			     varPtSizExtrTransfR[2] * p + varPtSizExtrTransfT.p[2]);\n"
"\n"
"MOV  R3, v[OPOS];		#  (temp: R3 takes v[OPOS], since only one v[] per op allowed)\n"
"DP3  R1.x, c[8], R3;		# pViewLocal.x = varPtSizExtrTransfR[0] * p\n"
"DP3  R1.y, c[9], R3;		# pViewLocal.y = varPtSizExtrTransfR[1] * p\n"
"DP3  R1.z, c[10], R3;		# pViewLocal.z = varPtSizExtrTransfR[2] * p\n"
"ADD  R1, c[64], R1;		# add varPtSizExtrTransfT to pViewLocal\n"
"\n"
"# now, 'z' is in R1.z:\n"
"#  const float  z = pViewLocal.p[2];\n"
"#\n"
"\n"
"# viewD to R1 (pViewLocal isn't needed anymore):\n"
"#  const VectorR3  viewD = ((varPtSizF2 / (z*z*z)) * pViewLocal);\n"
"#\n"
"MUL  R2, R1.z, R1.z;		#  (R2 = z*z)\n"
"MUL  R2, R2, R1.z;	        #  (R2 = z*z*z)\n"
"RCP  R2, R2.z;			#  (R2 = 1/(z*z*z))\n"
"MUL  R2, c[68].x, R2;		#  (R2 = varPtSizF2/(z*z*z))\n"
"MUL  R1, R2, R1;		#  (R1 = ((varPtSizF2 / (z*z*z)) * pViewLocal))\n"
"\n"
"# size to R1 (viewD is not needed anymore):\n"
"#  const float  size = sqrt(viewD.abs()) * 2*r;\n"
"#\n"
"#  -- in fact, we compute size = 1/(sqrt(1/sqrt(viewD * viewD) * 1/((2*r)^2)))\n"
"#\n"
"#     Thus, the OpenGL-App must encode the radius by setting the\n"
"#     normal to a length of 1/(2r)!!\n"
"#\n"
"#\n"
"DP3  R1, R1, R1;		#  (R1 = viewD*viewD)\n"
"RSQ  R1, R1.x;			#  (R1 = 1/(viewD.abs()))\n"
"DP3  R4, v[NRML], v[NRML];	#  (R2 = nrml.sqabs())\n"
"MUL  R1, R1.x, R4.x;		#  (R1 = 1/(viewD.abs()) * nrml.sqabs())\n"
"RSQ  o[PSIZ], R1.x;		#  (PSIZ = sqrt(viewD.abs()) * 1/nrml.abs())\n"
"\n"
"# Now, by the way, the squared normal is in R4\n"
"\n"
"# Point color\n"
"#\n"
"##MOV  o[COL0], v[COL0].yzxw;\n"
"#MOV  o[COL0], v[COL0];\n"
"\n"
"# Compute lighting for directional light and local viewer\n"
"#\n"
"#   normalized light direction in c[32]; light direction must\n"
"#   be in *object* coordinates\n"
"#\n"
"ADD R0, c[65], -v[OPOS];	# view-vector in object coords...\n"
"DP3 R1, R0, R0;\n"
"RSQ R1.x, R1.x;\n"
"MUL R0, R1.xxxx, R0;		# ... normalized\n"
"\n"
"#DP3 R1, v[NRML], v[NRML];	# normal...\n"
"#RSQ R1.x, R1.x;\n"
"RSQ R1.x, R4.x;			#         we already stored the squared normal in R4\n"
"MUL R1, R1.xxxx, v[NRML];	# ... normalized\n"
"\n"
"ADD R2, c[32], R0;		# half-way vector to R2...\n"
"DP3 R6, R2, R2;\n"
"RSQ R6, R6.x;\n"
"MUL R2, R6.xxxx, R2;		# ... done\n"
"DP3 R0.y, R2, R1;		# dp3 normal / half-way vector (specular term)\n"
"\n"
"DP3 R0.x, c[32], R1;		# dp3 normal / light vector (diffuse term)\n"
"\n"
"#MOV R0.w, c[57].x;		# specular coefficient of 100\n"
"#MOV R0.w, c[50].w;		# specular coefficient of 2\n"
"MOV R0.w, c[52].x;		# specular coefficient of 3\n"
"\n"
"LIT R0, R0;\n"
"\n"
"# Now in R0: coeffs {amb, diff, spec, 1.0}\n"
"\n"
"MUL  R1, R0.yyyy, v[COL0];		# diffuse term\n"
"#MAD  o[COL0], R0.xxxx, c[51].xxxx, R1;	# ambient term\n"
"MAD  o[COL0], R0.zzzz, c[56].xxxx, R1;	# specular term\n"
"#MOV  o[COL0], R0.zyyw;			# enable this for color encoded lighting vis\n"
"\n"
"END\n"
